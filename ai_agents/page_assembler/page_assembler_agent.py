#!/usr/bin/env python3
"""
Page Assembler Agent for the Website Expansion Framework.

This module provides the Page Assembler Agent implementation, responsible for
building complete HTML pages with proper structure from generated content.
"""

import os
import json
import asyncio
import logging
from typing import Dict, Any, List, Optional
from pathlib import Path

# Import base agent
import sys
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))
from ai_agents.shared.base_agent import BaseAgent

# Import ADK components
from google.adk.agents import Agent
from google.genai.types import Content, Part

logger = logging.getLogger(__name__)

class PageAssemblerAgent(BaseAgent):
    """
    Agent responsible for assembling HTML pages from generated content.
    
    The Page Assembler Agent takes structured content generated by the Content Generator
    and builds complete HTML pages ready for publishing, including proper HTML structure,
    schema markup, and SEO elements.
    """
    
    def __init__(self, config_path: str = "config/agent_config.yaml"):
        """
        Initialize the Page Assembler Agent.
        
        Args:
            config_path: Path to the agent configuration file
        """
        super().__init__("page_assembler", config_path)
        self.template_directory = self.agent_config.get('template_directory', './data/templates')
    
    def _get_html_template(self) -> str:
        """
        Get the base HTML template.
        
        Returns:
            str: HTML template
        """
        # This is a simple HTML template, in a real implementation this would be more sophisticated
        return """
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>{{meta_title}}</title>
            <meta name="description" content="{{meta_description}}">
            {{schema_markup}}
            <style>
                body { font-family: Arial, sans-serif; line-height: 1.6; margin: 0; padding: 0; color: #333; }
                .container { width: 90%; max-width: 1200px; margin: 0 auto; padding: 20px; }
                header { background-color: #f8f8f8; padding: 20px 0; }
                h1 { color: #2c3e50; margin-bottom: 20px; }
                h2 { color: #3498db; margin-top: 30px; }
                h3 { color: #2980b9; }
                .cta { background-color: #e67e22; color: white; padding: 20px; border-radius: 5px; margin: 30px 0; }
                .cta h2 { color: white; }
                .faq { background-color: #f9f9f9; padding: 20px; margin: 30px 0; border-radius: 5px; }
                footer { background-color: #2c3e50; color: white; padding: 20px 0; margin-top: 40px; }
            </style>
        </head>
        <body>
            <header>
                <div class="container">
                    <h1>{{h1_title}}</h1>
                </div>
            </header>
            
            <main class="container">
                {{main_content}}
                
                <div class="cta">
                    <h2>{{cta_title}}</h2>
                    <p>{{cta_content}}</p>
                </div>
                
                <div class="faq">
                    <h2>{{faq_title}}</h2>
                    {{faq_content}}
                </div>
            </main>
            
            <footer>
                <div class="container">
                    <p>&copy; {{current_year}} Professional Services. All rights reserved.</p>
                </div>
            </footer>
        </body>
        </html>
        """
    
    def _get_content_data(self, service_id: str, zip_code: str) -> Dict[str, Any]:
        """
        Get generated content data for a service and location.
        
        Args:
            service_id: The service ID
            zip_code: The zip code
            
        Returns:
            dict: Content data
        """
        try:
            content_path = f"data/pages/{service_id}/{zip_code}.json"
            if os.path.exists(content_path):
                with open(content_path, 'r') as f:
                    return json.load(f)
            else:
                self.logger.warning(f"Content data not found for {service_id}/{zip_code}")
                return {}
        except Exception as e:
            self.logger.error(f"Failed to load content data for {service_id}/{zip_code}: {str(e)}")
            return {}
    
    def _generate_schema_markup(self, content_data: Dict[str, Any]) -> str:
        """
        Generate schema.org markup for the page.
        
        Args:
            content_data: Content data with service and location information
            
        Returns:
            str: JSON-LD schema markup
        """
        # This is a simple implementation
        service_id = content_data.get('service_id', '')
        service_display = content_data.get('service_display', service_id.capitalize())
        city = content_data.get('location', {}).get('city', '')
        state = content_data.get('location', {}).get('state', '')
        zip_code = content_data.get('zip_code', '')
        
        schema = {
            "@context": "https://schema.org",
            "@type": "LocalBusiness",
            "name": f"Professional {service_display} Services",
            "description": f"Expert {service_display.lower()} services in {city}, {state}.",
            "address": {
                "@type": "PostalAddress",
                "addressLocality": city,
                "addressRegion": state,
                "postalCode": zip_code,
                "addressCountry": "US"
            },
            "geo": {
                "@type": "GeoCoordinates",
                "latitude": content_data.get('location', {}).get('lat', 0),
                "longitude": content_data.get('location', {}).get('lng', 0)
            },
            "telephone": "(555) 555-5555",
            "priceRange": "$$$"
        }
        
        return f'<script type="application/ld+json">{json.dumps(schema)}</script>'
    
    def initialize_agent(self):
        """
        Initialize the Page Assembler Agent.
        """
        # Additional agent-specific instruction
        instruction = self.agent_config.get('instruction', '')
        instruction += """
        Your task is to assemble complete HTML pages from structured content data.
        For each task:
        1. Take the structured content generated for a specific service and location
        2. Apply the appropriate HTML template
        3. Incorporate all content sections in their proper places
        4. Ensure all meta tags and SEO elements are properly formatted
        5. Add appropriate schema.org markup for local businesses
        6. Generate valid, well-structured HTML that is ready for publishing
        
        Ensure the final HTML is properly formatted, includes all necessary CSS,
        and validates against HTML5 standards.
        """
        
        self.agent_config['instruction'] = instruction
        
        # Initialize the agent
        super().initialize_agent()
    
    async def process_task(self, task: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process a single page assembly task.
        
        Args:
            task: The task to process, including service and location
            
        Returns:
            dict: Assembled page data
        """
        task_id = task.get('task_id')
        service_id = task.get('service_id')
        zip_code = task.get('zip')
        
        self.logger.info(f"Assembling page for task {task_id}: {service_id} + {zip_code}")
        self.start_task_timer()
        
        try:
            # Get content data
            content_data = self._get_content_data(service_id, zip_code)
            
            if not content_data or 'content' not in content_data:
                raise ValueError(f"Content data not found or incomplete for {service_id}/{zip_code}")
            
            # Get HTML template
            html_template = self._get_html_template()
            
            # Prepare the message for the agent
            content_json = json.dumps(content_data, indent=2)
            prompt = f"Assemble an HTML page for {service_id} services in zip code {zip_code}. "
            prompt += f"Use the following content data: \n```json\n{content_json}\n```\n\n"
            prompt += f"Apply this HTML template: \n```html\n{html_template}\n```\n\n"
            prompt += "Generate the complete HTML page ready for publishing. Follow all SEO best practices."
            
            content = Content(
                role='user',
                parts=[Part(text=prompt)]
            )
            
            # Generate a unique session ID for this task
            session_id = f"assembly_{task_id}"
            user_id = "website_expander"
            
            result = {
                "service_id": service_id,
                "zip_code": zip_code,
                "status": "processing"
            }
            
            # Process the task using the Page Assembler Agent
            async for event in self.runner.run_async(
                user_id=user_id,
                session_id=session_id,
                new_message=content
            ):
                # Check for the final response
                if event.is_final_response() and event.content and event.content.parts:
                    response_text = event.content.parts[0].text
                    
                    # Extract HTML from the response
                    import re
                    html_match = re.search(r'```html\n(.+?)\n```', response_text, re.DOTALL)
                    
                    if html_match:
                        html_content = html_match.group(1)
                        result["html"] = html_content
                        result["status"] = "completed"
                    else:
                        # If no HTML block found, assume the entire response is HTML
                        # This is a fallback and might not be ideal
                        self.logger.warning("HTML not found in code block, using raw response")
                        result["html"] = response_text
                        result["status"] = "completed"
            
            elapsed = self.end_task_timer()
            self.log_task_completion(task_id, "completed", elapsed)
            
            # Save the assembled HTML
            output_dir = f"data/assembled_pages/{service_id}"
            os.makedirs(output_dir, exist_ok=True)
            
            # Save HTML to file
            with open(f"{output_dir}/{zip_code}.html", 'w') as f:
                f.write(result["html"])
            
            # Save metadata
            metadata = {
                "service_id": service_id,
                "zip_code": zip_code,
                "url_slug": f"{service_id}/{zip_code}",
                "status": "assembled",
                "assembled_at": datetime.now().isoformat()
            }
            
            with open(f"{output_dir}/{zip_code}.meta.json", 'w') as f:
                json.dump(metadata, f, indent=2)
            
            result["metadata"] = metadata
            return result
            
        except Exception as e:
            elapsed = self.end_task_timer()
            self.logger.error(f"Error assembling page for task {task_id}: {str(e)}")
            
            result = {
                "service_id": service_id,
                "zip_code": zip_code,
                "status": "error",
                "error": str(e)
            }
            
            self.log_task_completion(task_id, "error", elapsed, result)
            return result
